//
// Copyright (C) 2008-2021 Jonathan Moore Liles (as "Non-Timeline")
// Copyright (C) 2023- Stazed
//
// This file is part of Non-Timeline-XT
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//

// generated by Fast Light User Interface Designer (fluid) version 1.0309

#ifndef TLE_H
#define TLE_H
#include <FL/Fl.H>
class Fl_Flowpack;
#include "Clock.H"

class TLE_Window : public Fl_Overlay_Window {
public:
  TLE_Window(int W, int H, const char *L = 0) ;
  void draw_overlay(void);
  virtual ~TLE_Window();
};
#include <FL/Fl_Group.H>
#include <FL/Fl_Menu_Bar.H>
#ifdef FLTK_SUPPORT
   #include "../../FL/Fl_Theme_Chooser.H"
#else
    #include <FL/Fl_Theme_Chooser.H>
 #endif
#include <FL/Fl_Pack.H>
#include <FL/Fl_Box.H>
#include <FL/Fl_Progress.H>
#include <FL/Fl_Button.H>
#include "../../FL/Fl_Blink_Button.H"

class TLE {
  Fl_Color system_colors[3]; 
  int _x_main, _y_main, _w_main, _h_main; 
public:
  void save_options();
  void save();
  void quit();
  void save_window_sizes();
  void load_window_sizes();
  bool open( const char *name );
  void save_timeline_settings();
private:
  void reset_timeline_settings( void );
public:
  void load_timeline_settings();
  void run();
  TLE();
  TLE_Window* make_window();
  TLE_Window *main_window;
private:
  inline void cb_main_window_i(TLE_Window*, void*);
  static void cb_main_window(TLE_Window*, void*);
  Fl_Menu_Bar *menubar;
  static Fl_Menu_Item menu_menubar[];
  inline void cb_Info_i(Fl_Menu_*, void*);
  static void cb_Info(Fl_Menu_*, void*);
  inline void cb_Follow_i(Fl_Menu_*, void*);
  static void cb_Follow(Fl_Menu_*, void*);
  inline void cb_Center_i(Fl_Menu_*, void*);
  static void cb_Center(Fl_Menu_*, void*);
  inline void cb_Bars_i(Fl_Menu_*, void*);
  static void cb_Bars(Fl_Menu_*, void*);
  inline void cb_Beats_i(Fl_Menu_*, void*);
  static void cb_Beats(Fl_Menu_*, void*);
  inline void cb_Off_i(Fl_Menu_*, void*);
  static void cb_Off(Fl_Menu_*, void*);
  inline void cb_Magnetic_i(Fl_Menu_*, void*);
  static void cb_Magnetic(Fl_Menu_*, void*);
  inline void cb_Playback_i(Fl_Menu_*, void*);
  static void cb_Playback(Fl_Menu_*, void*);
  inline void cb_New_i(Fl_Menu_*, void*);
  static void cb_New(Fl_Menu_*, void*);
  inline void cb_Open_i(Fl_Menu_*, void*);
  static void cb_Open(Fl_Menu_*, void*);
  inline void cb_Compact_i(Fl_Menu_*, void*);
  static void cb_Compact(Fl_Menu_*, void*);
  inline void cb_Quit_i(Fl_Menu_*, void*);
  static void cb_Quit(Fl_Menu_*, void*);
  inline void cb_Undo_i(Fl_Menu_*, void*);
  static void cb_Undo(Fl_Menu_*, void*);
  inline void cb_Select_i(Fl_Menu_*, void*);
  static void cb_Select(Fl_Menu_*, void*);
  inline void cb_Delete_i(Fl_Menu_*, void*);
  static void cb_Delete(Fl_Menu_*, void*);
  inline void cb_Start_i(Fl_Menu_*, void*);
  static void cb_Start(Fl_Menu_*, void*);
  inline void cb_End_i(Fl_Menu_*, void*);
  static void cb_End(Fl_Menu_*, void*);
  inline void cb_Play_i(Fl_Menu_*, void*);
  static void cb_Play(Fl_Menu_*, void*);
  inline void cb_Record_i(Fl_Menu_*, void*);
  static void cb_Record(Fl_Menu_*, void*);
  inline void cb_In_i(Fl_Menu_*, void*);
  static void cb_In(Fl_Menu_*, void*);
  inline void cb_Out_i(Fl_Menu_*, void*);
  static void cb_Out(Fl_Menu_*, void*);
  inline void cb_Fit_i(Fl_Menu_*, void*);
  static void cb_Fit(Fl_Menu_*, void*);
  inline void cb_1_i(Fl_Menu_*, void*);
  static void cb_1(Fl_Menu_*, void*);
  inline void cb_11_i(Fl_Menu_*, void*);
  static void cb_11(Fl_Menu_*, void*);
  inline void cb_12_i(Fl_Menu_*, void*);
  static void cb_12(Fl_Menu_*, void*);
  inline void cb_Theme_i(Fl_Menu_*, void*);
  static void cb_Theme(Fl_Menu_*, void*);
  inline void cb_Measure_i(Fl_Menu_*, void*);
  static void cb_Measure(Fl_Menu_*, void*);
  inline void cb_Cursor_i(Fl_Menu_*, void*);
  static void cb_Cursor(Fl_Menu_*, void*);
  inline void cb_Fill_i(Fl_Menu_*, void*);
  static void cb_Fill(Fl_Menu_*, void*);
  inline void cb_Outline_i(Fl_Menu_*, void*);
  static void cb_Outline(Fl_Menu_*, void*);
  inline void cb_Vary_i(Fl_Menu_*, void*);
  static void cb_Vary(Fl_Menu_*, void*);
  inline void cb_Inherit_i(Fl_Menu_*, void*);
  static void cb_Inherit(Fl_Menu_*, void*);
  inline void cb_Show_i(Fl_Menu_*, void*);
  static void cb_Show(Fl_Menu_*, void*);
  inline void cb_Ruled_i(Fl_Menu_*, void*);
  static void cb_Ruled(Fl_Menu_*, void*);
  inline void cb_Colored_i(Fl_Menu_*, void*);
  static void cb_Colored(Fl_Menu_*, void*);
  inline void cb_Stop_i(Fl_Menu_*, void*);
  static void cb_Stop(Fl_Menu_*, void*);
  inline void cb_Loop_i(Fl_Menu_*, void*);
  static void cb_Loop(Fl_Menu_*, void*);
  inline void cb_Automatically_i(Fl_Menu_*, void*);
  static void cb_Automatically(Fl_Menu_*, void*);
  inline void cb_Manual_i(Fl_Menu_*, void*);
  static void cb_Manual(Fl_Menu_*, void*);
  inline void cb_About_i(Fl_Menu_*, void*);
  static void cb_About(Fl_Menu_*, void*);
  Fl_Pack *clocks_pack;
  Fl_Progress *capture_buffer_progress;
  Fl_Progress *cpu_load_progress;
  Fl_Progress *playback_buffer_progress;
  Fl_Progress *disk_usage_progress;
public:
  Fl_Button *follow_transport;
private:
  inline void cb_follow_transport_i(Fl_Button*, void*);
  static void cb_follow_transport(Fl_Button*, void*);
public:
  Fl_Button *snap_toggle_bypass;
private:
  inline void cb_snap_toggle_bypass_i(Fl_Button*, void*);
  static void cb_snap_toggle_bypass(Fl_Button*, void*);
public:
  Fl_Blink_Button *solo_blinker;
  Fl_Blink_Button *rec_blinker;
  Fl_Blink_Button *selected_blinker;
  Fl_Blink_Button *seek_blinker;
  Fl_Blink_Button *xrun_blinker;
private:
  inline void cb_xrun_blinker_i(Fl_Blink_Button*, void*);
  static void cb_xrun_blinker(Fl_Blink_Button*, void*);
public:
  Fl_Button *stats_box;
  Fl_Button *sm_blinker;
  Fl_Group *progress_group;
private:
  Fl_Progress *progress;
  Fl_Box *project_name;
  static int menu_picked_value( const Fl_Menu_ *m );
  static Fl_Menu_Item * find_item( Fl_Menu_ *menu, const char *path );
  static void menubar_cb ( void *v ); 
  void menubar_cb ( void ); 
  void update_menu();
  static void update_progress( Fl_Progress *p, char *s, float v );
  void update_status();
  static void update_cb( void *v );
  static void capture_format_cb( Fl_Widget *, void *v );
  void capture_format_cb();
  static void progress_cb( int p, void *arg );
  void progress_cb( int p );
  static void show_help_dialog( const char *file );
};
extern "C" { void set_theme_dark(); }
#include <FL/Fl_Double_Window.H>
#include <FL/Fl_Value_Output.H>
#include <FL/Fl_Output.H>
#include "../../nonlib/file.h"
#include <FL/Fl_Text_Editor.H>

class Project_Info_Dialog {
public:
  Project_Info_Dialog();
  void run();
  Fl_Double_Window* make_window();
private:
  Fl_Double_Window *window;
  inline void cb_window_i(Fl_Double_Window*, void*);
  static void cb_window(Fl_Double_Window*, void*);
  Fl_Box *logo_box;
  Fl_Text_Editor *notes_field;
  inline void cb_Save_i(Fl_Button*, void*);
  static void cb_Save(Fl_Button*, void*);
  inline void cb_Discard_i(Fl_Button*, void*);
  static void cb_Discard(Fl_Button*, void*);
};
#endif
