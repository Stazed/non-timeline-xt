//
// Copyright (C) 2008-2021 Jonathan Moore Liles (as "Non-Timeline")
// Copyright (C) 2023- Stazed
//
// This file is part of Non-Timeline-XT
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//

// generated by Fast Light User Interface Designer (fluid) version 1.0309

#include "TLE.H"
static const float STATUS_UPDATE_FREQ = 0.5f; 
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <FL/Fl_Overlay_Window.H>
#include "../../FL/Fl_Menu_Settings.H"
#include "Timeline.H"
#include "Transport.H"
#include "../../nonlib/Loggable.H"
#include "Project.H"
#include "../../FL/Fl_Flowpack.H"
#include "../../FL/New_Project_Dialog.H"
#include "Track.H" // for capture_format
#include "Waveform.H" // for options
#include "Audio_Region.H" // for options
#include "Control_Sequence.H" // for options
#include <FL/Fl_File_Chooser.H>
#include <FL/Fl_Shared_Image.H>
#include <FL/Fl.H>
#include <FL/fl_ask.H>
#include "Engine/Engine.H"
#include "Engine/Audio_File.H" // for supported formats
#include "../../FL/About_Dialog.H"
extern char project_display_name[256];
#include "../../nonlib/nsm.h"
extern nsm_client_t *nsm;
extern char *user_config_dir;
extern const char *APP_NAME;

TLE_Window::TLE_Window(int W, int H, const char *L ) : Fl_Overlay_Window( W, H, L ) {
}

void TLE_Window::draw_overlay(void) {
  timeline->draw_overlay();
}

TLE_Window::~TLE_Window() {
}

void TLE::cb_main_window_i(TLE_Window*, void*) {
  if ( Fl::event_key() != FL_Escape )
{
    if ( timeline->session_manager_name() != NULL )
    {
        timeline->command_hide_gui();
    }
    else
    {
        timeline->command_quit();
    }
};
}
void TLE::cb_main_window(TLE_Window* o, void* v) {
  ((TLE*)(o->user_data()))->cb_main_window_i(o,v);
}

void TLE::cb_Info_i(Fl_Menu_*, void*) {
  Project_Info_Dialog pi;

pi.run();
}
void TLE::cb_Info(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Info_i(o,v);
}

void TLE::cb_Follow_i(Fl_Menu_* o, void*) {
  Timeline::follow_playhead = menu_picked_value( o );
follow_transport->value(Timeline::follow_playhead);
}
void TLE::cb_Follow(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Follow_i(o,v);
}

void TLE::cb_Center_i(Fl_Menu_* o, void*) {
  Timeline::center_playhead = menu_picked_value( o );
}
void TLE::cb_Center(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Center_i(o,v);
}

void TLE::cb_Bars_i(Fl_Menu_*, void*) {
  Timeline::snap_to = Timeline::Bars;
}
void TLE::cb_Bars(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Bars_i(o,v);
}

void TLE::cb_Beats_i(Fl_Menu_*, void*) {
  Timeline::snap_to = Timeline::Beats;
}
void TLE::cb_Beats(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Beats_i(o,v);
}

void TLE::cb_Off_i(Fl_Menu_*, void*) {
  Timeline::snap_to = Timeline::None;
}
void TLE::cb_Off(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Off_i(o,v);
}

void TLE::cb_Magnetic_i(Fl_Menu_* o, void*) {
  Timeline::snap_magnetic = menu_picked_value( o );
}
void TLE::cb_Magnetic(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Magnetic_i(o,v);
}

void TLE::cb_Playback_i(Fl_Menu_* o, void*) {
  Timeline::playback_latency_compensation = menu_picked_value( o );
}
void TLE::cb_Playback(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Playback_i(o,v);
}

void TLE::cb_New_i(Fl_Menu_*, void*) {
  save_timeline_settings();

              
        char *result_path;    

        char *default_path = read_line( user_config_dir, "default_path" );
        result_path = default_path;

        char *path = new_project_chooser( &result_path );

        if ( path )
        {
            if ( ! Project::create( path, NULL ) )
                fl_alert( "Error creating project!" );
            free( path );
        }

        if ( result_path != default_path )
            free(default_path);

        if ( result_path )
        {
            write_line( user_config_dir, "default_path", result_path );
            free( result_path );
        }


load_timeline_settings();

update_menu();

main_window->redraw();
}
void TLE::cb_New(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_New_i(o,v);
}

void TLE::cb_Open_i(Fl_Menu_*, void*) {
  char *path = read_line( user_config_dir, "default_path" );

const char *name = fl_dir_chooser( "Open Project", path );

if(open( name ))
{
   std::string s_name(name);
   std::size_t found = s_name.find_last_of("/\\");

   std::string s_base_dir = s_name.substr(0, found);

   if ( path )
   {
       // If the path to opened project is different from default, then update the default path
       if( strcmp( path, s_base_dir.c_str() ) )
       {
           write_line( user_config_dir, "default_path", s_base_dir.c_str() );
       }
   }
   else    // No path previously set, so set it now
       write_line( user_config_dir, "default_path", s_base_dir.c_str() );
}

free( path );
}
void TLE::cb_Open(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Open_i(o,v);
}

void TLE::cb_Compact_i(Fl_Menu_*, void*) {
  int n = fl_choice( "Compacting will replace the project history with a snapshot of the current state.\nYou will not be able to use Undo to go back beyond this point.\n\nThis operation is irreversible!", NULL, "&Cancel", "Pr&ocede with compaction" );

if ( n != 2 )
	return;
	
Project::compact();
}
void TLE::cb_Compact(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Compact_i(o,v);
}

void TLE::cb_Quit_i(Fl_Menu_*, void*) {
  quit();
}
void TLE::cb_Quit(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Quit_i(o,v);
}

void TLE::cb_Undo_i(Fl_Menu_*, void*) {
  timeline->command_undo();
}
void TLE::cb_Undo(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Undo_i(o,v);
}

void TLE::cb_Select_i(Fl_Menu_*, void*) {
  timeline->select_none();
}
void TLE::cb_Select(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Select_i(o,v);
}

void TLE::cb_Delete_i(Fl_Menu_*, void*) {
  timeline->delete_selected();
}
void TLE::cb_Delete(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Delete_i(o,v);
}

void TLE::cb_Start_i(Fl_Menu_*, void*) {
  transport->locate( 0 );
}
void TLE::cb_Start(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Start_i(o,v);
}

void TLE::cb_End_i(Fl_Menu_*, void*) {
  transport->locate( timeline->length() );
}
void TLE::cb_End(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_End_i(o,v);
}

void TLE::cb_Play_i(Fl_Menu_*, void*) {
  transport->toggle();
}
void TLE::cb_Play(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Play_i(o,v);
}

void TLE::cb_Record_i(Fl_Menu_*, void*) {
  transport->toggle_record();
}
void TLE::cb_Record(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Record_i(o,v);
}

void TLE::cb_In_i(Fl_Menu_*, void*) {
  timeline->zoom_in();
}
void TLE::cb_In(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_In_i(o,v);
}

void TLE::cb_Out_i(Fl_Menu_*, void*) {
  timeline->zoom_out();
}
void TLE::cb_Out(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Out_i(o,v);
}

void TLE::cb_Fit_i(Fl_Menu_*, void*) {
  timeline->zoom_fit();
}
void TLE::cb_Fit(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Fit_i(o,v);
}

void TLE::cb_1_i(Fl_Menu_*, void*) {
  timeline->zoom( 1 );
}
void TLE::cb_1(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_1_i(o,v);
}

void TLE::cb_11_i(Fl_Menu_*, void*) {
  timeline->zoom( 60 );
}
void TLE::cb_11(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_11_i(o,v);
}

void TLE::cb_12_i(Fl_Menu_*, void*) {
  timeline->zoom( 60 * 60 );
}
void TLE::cb_12(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_12_i(o,v);
}

void TLE::cb_Theme_i(Fl_Menu_*, void*) {
  fl_theme_chooser();
}
void TLE::cb_Theme(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Theme_i(o,v);
}

void TLE::cb_Measure_i(Fl_Menu_* o, void*) {
  Timeline::draw_with_measure_lines = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Measure(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Measure_i(o,v);
}

void TLE::cb_Cursor_i(Fl_Menu_* o, void*) {
  Timeline::draw_with_cursor_overlay = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Cursor(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Cursor_i(o,v);
}

void TLE::cb_Fill_i(Fl_Menu_* o, void*) {
  Waveform::fill = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Fill(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Fill_i(o,v);
}

void TLE::cb_Outline_i(Fl_Menu_* o, void*) {
  Waveform::outline = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Outline(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Outline_i(o,v);
}

void TLE::cb_Vary_i(Fl_Menu_* o, void*) {
  Waveform::vary_color = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Vary(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Vary_i(o,v);
}

void TLE::cb_Inherit_i(Fl_Menu_* o, void*) {
  Audio_Region::inherit_track_color = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Inherit(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Inherit_i(o,v);
}

void TLE::cb_Show_i(Fl_Menu_* o, void*) {
  Audio_Region::show_box = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Show(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Show_i(o,v);
}

void TLE::cb_Ruled_i(Fl_Menu_* o, void*) {
  Control_Sequence::draw_with_grid = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Ruled(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Ruled_i(o,v);
}

void TLE::cb_Colored_i(Fl_Menu_* o, void*) {
  Track::colored_tracks = menu_picked_value( o );

timeline->redraw();
}
void TLE::cb_Colored(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Colored_i(o,v);
}

void TLE::cb_Stop_i(Fl_Menu_* o, void*) {
  transport->stop_disables_record( ((Fl_Menu_*)o)->mvalue()->flags & FL_MENU_VALUE );
}
void TLE::cb_Stop(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Stop_i(o,v);
}

void TLE::cb_Loop_i(Fl_Menu_* o, void*) {
  transport->loop_enabled( ( ((Fl_Menu_*)o)->mvalue()->flags & FL_MENU_VALUE )) ;
}
void TLE::cb_Loop(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Loop_i(o,v);
}

void TLE::cb_Automatically_i(Fl_Menu_* o, void*) {
  transport->automatically_create_takes( ( ((Fl_Menu_*)o)->mvalue()->flags & FL_MENU_VALUE ));
}
void TLE::cb_Automatically(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Automatically_i(o,v);
}

void TLE::cb_Manual_i(Fl_Menu_*, void*) {
  show_help_dialog( "MANUAL" );
}
void TLE::cb_Manual(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_Manual_i(o,v);
}

void TLE::cb_About_i(Fl_Menu_*, void*) {
  About_Dialog ab( PIXMAP_PATH "/non-timeline-xt/icon-256x256.png" );

	std::string s_logo = BUILD_TYPE_CMAKE;
        s_logo += " ";
        s_logo += VERSION;
        s_logo += "\n";
        s_logo += BUILD_TYPE;
        ab.logo_box->label( s_logo.c_str() );

        ab.title->label( "Non Timeline XT" );

        ab.copyright->label( "Copyright (C) 2008-2021 Jonathan Moore Liles (as Non-Timeline)\n Copyright (C) 2023-Stazed (Non-Timeline-XT)" );
        ab.credits->label( "Legacy Non Timeline was written by\nJonathan Moore Liles.\n\n Non Timeline XT by Stazed." );

        ab.website_url->label( "https://github.com/Stazed/non-timeline-xt" );

ab.run();
}
void TLE::cb_About(Fl_Menu_* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_About_i(o,v);
}

Fl_Menu_Item TLE::menu_menubar[] = {
 {"&Project", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Info", 0,  (Fl_Callback*)TLE::cb_Info, 0, 1, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Se&ttings", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Follow Playhead", 0,  (Fl_Callback*)TLE::cb_Follow, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Center Playhead", 0,  (Fl_Callback*)TLE::cb_Center, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Snap to", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Bars", 0,  (Fl_Callback*)TLE::cb_Bars, 0, 12, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Beats", 0,  (Fl_Callback*)TLE::cb_Beats, 0, 8, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Off", 0,  (Fl_Callback*)TLE::cb_Off, 0, 8, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Magnetic snap", 0,  (Fl_Callback*)TLE::cb_Magnetic, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Capture Format", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Playback Latency Compensation", 0,  (Fl_Callback*)TLE::cb_Playback, 0, 2, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&New", 0,  (Fl_Callback*)TLE::cb_New, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Open", 0,  (Fl_Callback*)TLE::cb_Open, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Compact", 0,  (Fl_Callback*)TLE::cb_Compact, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Quit", 0x40071,  (Fl_Callback*)TLE::cb_Quit, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Edit", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Undo", 0x4007a,  (Fl_Callback*)TLE::cb_Undo, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Select None", 0x50061,  (Fl_Callback*)TLE::cb_Select, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Delete  Selected", 0xffff,  (Fl_Callback*)TLE::cb_Delete, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"T&ransport", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Start", 0xff50,  (Fl_Callback*)TLE::cb_Start, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"End", 0xff57,  (Fl_Callback*)TLE::cb_End, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Play/Stop", 0x20,  (Fl_Callback*)TLE::cb_Play, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Record", 0x10072,  (Fl_Callback*)TLE::cb_Record, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Timeline", 0,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&View", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Zoom", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&In", 0x2b,  (Fl_Callback*)TLE::cb_In, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Out", 0x5f,  (Fl_Callback*)TLE::cb_Out, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Fit", 0x3d,  (Fl_Callback*)TLE::cb_Fit, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"1 sec.", 0x31,  (Fl_Callback*)TLE::cb_1, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"1 min.", 0x32,  (Fl_Callback*)TLE::cb_11, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"1 hour.", 0x33,  (Fl_Callback*)TLE::cb_12, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Theme", 0,  (Fl_Callback*)TLE::cb_Theme, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Options", 0,  0, 0, 192, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Display", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Timeline", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Measure lines", 0,  (Fl_Callback*)TLE::cb_Measure, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Cursor Overlay", 0,  (Fl_Callback*)TLE::cb_Cursor, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Waveform", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Fill", 0,  (Fl_Callback*)TLE::cb_Fill, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Outline", 0,  (Fl_Callback*)TLE::cb_Outline, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Vary color", 0,  (Fl_Callback*)TLE::cb_Vary, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Region", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Filled fades", 0,  0, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Inherit track color", 0,  (Fl_Callback*)TLE::cb_Inherit, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Show box", 0,  (Fl_Callback*)TLE::cb_Show, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Control Sequence", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Ruled", 0,  (Fl_Callback*)TLE::cb_Ruled, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"&Track", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Colored tracks", 0,  (Fl_Callback*)TLE::cb_Colored, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {"&Behavior", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Transport", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Stop Disables Record", 0,  (Fl_Callback*)TLE::cb_Stop, 0, 6, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Loop Playback", 0,  (Fl_Callback*)TLE::cb_Loop, 0, 2, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"Automatically Create Takes", 0,  (Fl_Callback*)TLE::cb_Automatically, 0, 2, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {"&Help", 0,  0, 0, 64, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&Manual", 0,  (Fl_Callback*)TLE::cb_Manual, 0, 128, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {"&About", 0,  (Fl_Callback*)TLE::cb_About, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

void TLE::cb_follow_transport_i(Fl_Button*, void*) {
  Timeline::follow_playhead = !Timeline::follow_playhead;

Fl_Menu_Item *m = const_cast<Fl_Menu_Item*>( menubar->find_item( "&Project/Se&ttings/&Follow Playhead" ) );

if(Timeline::follow_playhead)
   m->set();
else
   m->clear();
}
void TLE::cb_follow_transport(Fl_Button* o, void* v) {
  ((TLE*)(o->parent()->parent()->parent()->user_data()))->cb_follow_transport_i(o,v);
}

void TLE::cb_snap_toggle_bypass_i(Fl_Button* o, void*) {
  Timeline::snap_toggle_bypass = !o->value();
}
void TLE::cb_snap_toggle_bypass(Fl_Button* o, void* v) {
  ((TLE*)(o->parent()->parent()->parent()->user_data()))->cb_snap_toggle_bypass_i(o,v);
}

void TLE::cb_xrun_blinker_i(Fl_Blink_Button*, void*) {
  if ( engine && ! engine->zombified() )
{
    engine->clear_xruns();
};
}
void TLE::cb_xrun_blinker(Fl_Blink_Button* o, void* v) {
  ((TLE*)(o->parent()->parent()->user_data()))->cb_xrun_blinker_i(o,v);
}

void TLE::save_options() {
  const char options_filename[] = "options";
    // const char state_filename[] = "state";
    
    // save options
    
    char *path;
    asprintf( &path, "%s/%s", user_config_dir, options_filename );
    ((Fl_Menu_Settings*)menubar)->dump( menubar->find_item( "&Options" ), path );
    free( path );
}

void TLE::save() {
  timeline->command_save();
}

void TLE::quit() {
  if ( timeline->session_manager_name() != NULL )
  {
      timeline->command_hide_gui();
  }
  else
  {
      timeline->command_quit();
  }
}

void TLE::save_window_sizes() {
  if( ( _x_main == main_window->x() ) && ( _y_main ==  main_window->y() ) &&
           ( _w_main ==  main_window->w() ) && (_h_main == main_window->h() ) )
      {
          return; // nothing changed
      }
  
      FILE *fp = fopen ( "window", "w" );
  
      if ( !fp )
      {
          printf ( "Error opening window file for writing\n" );
          return;
      }
  
      fprintf ( fp, "%d:%d:%d:%d\n", main_window->x(), main_window->y(), main_window->w(), main_window->h());
  
      fclose ( fp );
}

void TLE::load_window_sizes() {
  FILE *fp = fopen ( "window", "r" );
  
      if ( !fp )
      {
          printf ( "Error opening window file for reading\n" );
          return;
      }
  
      while ( 4 == fscanf ( fp, "%d:%d:%d:%d\n]\n", &_x_main, &_y_main, &_w_main, &_h_main ) )
      {
      }
  
      main_window->resize ( _x_main, _y_main, _w_main, _h_main );
  
      fclose ( fp );
}

bool TLE::open( const char *name ) {
  return timeline->command_load( name, NULL );
}

void TLE::save_timeline_settings() {
  if ( ! Project::open() )
  	return;
  	
  
  // save project local options (Timeline menu)
  ((Fl_Menu_Settings*)menubar)->dump( menubar->find_item( "&Project/Se&ttings" ), "options" );
}

void TLE::reset_timeline_settings( void ) {
  char path[256];
  snprintf( path, sizeof( path ), "%s/%s", user_config_dir, ".default_project_settings" );
  
  ((Fl_Menu_Settings*)menubar)->load( menubar->find_item( "&Project/Se&ttings" ), path );
}

void TLE::load_timeline_settings() {
  reset_timeline_settings();
  
  
  if ( Project::open() )
  	((Fl_Menu_Settings*)menubar)->load( menubar->find_item( "&Project/Se&ttings" ), "options" );
  
  update_menu();
  
  follow_transport->value(Timeline::follow_playhead);
  
  project_name->redraw();
}

void TLE::run() {
  update_menu();
  
  // main_window->show();
  
  Fl::lock();
  
  // Fl::run();
}

TLE::TLE() {
  make_window();
  _x_main = 0;
  _y_main = 0;
  _w_main = 947;
  _h_main = 600;
  	
  Fl::visible_focus( 0 );
  
  // constrain window to size of screen.
  {
          int sx, sy, sw, sh;
  
          Fl::screen_xywh( sx, sy, sw, sh );
  
          main_window->size_range( 947, 500 );
          main_window->size( 947, 600 );
  
          if ( main_window->w() > sw ||
               main_window->h() > sh )
                  main_window->resize( sx, sy, sw, sh );
  }
  
  Fl::add_timeout( STATUS_UPDATE_FREQ, update_cb, this );
  
  fl_message_icon()->box( FL_RSHADOW_BOX );
  fl_message_icon()->labelcolor( FL_BLACK );
  fl_message_icon()->color( FL_RED );
  fl_message_font( FL_HELVETICA, 18 );
  
  
  std::list <const char *> formats;
  
  Audio_File::all_supported_formats( formats );
  
  for ( std::list <const char *>::const_iterator f = formats.begin(); f != formats.end(); ++f )
  {
  //	capture_format_menu->add( *f, FL_MENU_RADIO, 0, 0, 0 );
  //;
  	char pat[256];
  	snprintf( pat, sizeof( pat ), "&Project/Se&ttings/Capture Format/%s", *f );	
  
  	menubar->add( pat, 0, &TLE::capture_format_cb, this, FL_MENU_RADIO );
  }
  
  menubar->picked( menubar->find_item( "&Project/Se&ttings/Capture Format/Wav 24" ) );
  
  char *path;
  asprintf( &path, "%s/options", user_config_dir );
  ((Fl_Menu_Settings*)menubar)->load( menubar->find_item( "&Options" ), path );
  free( path );
  
  follow_transport->value(Timeline::follow_playhead);
  snap_toggle_bypass->value(!Timeline::snap_toggle_bypass);
  
  menubar->add( "&Timeline", 0, 0, const_cast< Fl_Menu_Item *>( timeline->menu->menu() ), FL_SUBMENU_POINTER );
  
  
  // save a copy of the project settings menu so that we can restore the defaults later
  {
  	char path[512];
  	snprintf( path, sizeof( path ), "%s/%s", user_config_dir, ".default_project_settings" );
  
  	((Fl_Menu_Settings*)menubar)->dump( menubar->find_item( "&Project/Se&ttings" ), path );
  }
  
  
  Loggable::progress_callback( &TLE::progress_cb, this );
}

TLE_Window* TLE::make_window() {
  { TLE_Window* o = main_window = new TLE_Window(1025, 770, "Non Timeline XT");
    main_window->box(FL_FLAT_BOX);
    main_window->color(FL_BACKGROUND_COLOR);
    main_window->selection_color(FL_BACKGROUND_COLOR);
    main_window->labeltype(FL_NO_LABEL);
    main_window->labelfont(0);
    main_window->labelsize(14);
    main_window->labelcolor(FL_FOREGROUND_COLOR);
    main_window->callback((Fl_Callback*)cb_main_window, (void*)(this));
    main_window->align(Fl_Align(FL_ALIGN_TOP));
    main_window->when(FL_WHEN_RELEASE);
    { Fl_Group* o = new Fl_Group(0, -53, 1025, 126);
      o->box(FL_FLAT_BOX);
      { menubar = new Fl_Menu_Bar(0, 0, 1025, 25);
        menubar->menu(menu_menubar);
      } // Fl_Menu_Bar* menubar
      { Fl_Pack* o = new Fl_Pack(1, 27, 584, 46);
        o->type(1);
        { Transport* o = new Transport(5, 28, 290, 44, "<Transport>");
          o->box(FL_NO_BOX);
          o->color((Fl_Color)30);
          o->selection_color(FL_BACKGROUND_COLOR);
          o->labeltype(FL_NORMAL_LABEL);
          o->labelfont(0);
          o->labelsize(14);
          o->labelcolor(FL_FOREGROUND_COLOR);
          o->align(Fl_Align(FL_ALIGN_CENTER));
          o->when(FL_WHEN_RELEASE);
          transport = o;
          o->labeltype( FL_NO_LABEL );
        } // Transport* o
        { Fl_Pack* o = clocks_pack = new Fl_Pack(295, 30, 290, 41);
          clocks_pack->type(1);
          { Clock* o = new Clock(301, 30, 137, 41, "PLAYHEAD");
            o->box(FL_FLAT_BOX);
            o->color(FL_DARK1);
            o->selection_color(FL_BACKGROUND_COLOR);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(0);
            o->labelsize(14);
            o->labelcolor(FL_FOREGROUND_COLOR);
            o->align(Fl_Align(FL_ALIGN_CENTER));
            o->when(FL_WHEN_RELEASE);
            o->type( Clock::HMS );
            _Pragma("GCC diagnostic push")
_Pragma("GCC diagnostic ignored \"-Waddress-of-packed-member\"")
            o->run( &transport->frame );
_Pragma("GCC diagnostic pop")
          } // Clock* o
          { Clock* o = new Clock(440, 30, 137, 41, "PLAYHEAD");
            o->box(FL_FLAT_BOX);
            o->color(FL_DARK1);
            o->selection_color(FL_BACKGROUND_COLOR);
            o->labeltype(FL_NORMAL_LABEL);
            o->labelfont(0);
            o->labelsize(14);
            o->labelcolor(FL_FOREGROUND_COLOR);
            o->align(Fl_Align(FL_ALIGN_CENTER));
            o->when(FL_WHEN_RELEASE);
            o->type( Clock::BBT );
            _Pragma("GCC diagnostic push")
_Pragma("GCC diagnostic ignored \"-Waddress-of-packed-member\"")
            o->run( &transport->frame );
_Pragma("GCC diagnostic pop")
          } // Clock* o
          o->spacing( 2 );
          clocks_pack->end();
        } // Fl_Pack* clocks_pack
        o->spacing( 10 );
        o->end();
      } // Fl_Pack* o
      { Fl_Box* o = new Fl_Box(585, 32, 155, 40, "<empty>");
        Fl_Group::current()->resizable(o);
        o->labeltype( FL_NO_LABEL );
      } // Fl_Box* o
      { Fl_Group* o = new Fl_Group(850, 23, 175, 50);
        { Fl_Box* o = new Fl_Box(910, 27, 56, 14, "capture:");
          o->labelsize(10);
          o->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
        } // Fl_Box* o
        { Fl_Box* o = new Fl_Box(910, 43, 56, 14, "playback:");
          o->labelsize(10);
          o->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
        } // Fl_Box* o
        { Fl_Box* o = new Fl_Box(910, 57, 56, 14, "DSP:");
          o->labelsize(10);
          o->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
        } // Fl_Box* o
        { Fl_Box* o = new Fl_Box(855, 28, 55, 18, "filesystem");
          o->labelsize(10);
          o->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
        } // Fl_Box* o
        { capture_buffer_progress = new Fl_Progress(965, 27, 60, 14, "50%");
          capture_buffer_progress->selection_color(FL_FOREGROUND_COLOR);
          capture_buffer_progress->labelsize(10);
        } // Fl_Progress* capture_buffer_progress
        { cpu_load_progress = new Fl_Progress(965, 57, 60, 14, "50%");
          cpu_load_progress->selection_color(FL_FOREGROUND_COLOR);
          cpu_load_progress->labelsize(9);
        } // Fl_Progress* cpu_load_progress
        { playback_buffer_progress = new Fl_Progress(965, 42, 60, 14, "50%");
          playback_buffer_progress->selection_color(FL_FOREGROUND_COLOR);
          playback_buffer_progress->labelsize(10);
        } // Fl_Progress* playback_buffer_progress
        { Fl_Progress* o = disk_usage_progress = new Fl_Progress(855, 43, 55, 28, "50%");
          disk_usage_progress->selection_color(FL_FOREGROUND_COLOR);
          disk_usage_progress->labelsize(10);
          o->type( FL_VERTICAL );
        } // Fl_Progress* disk_usage_progress
        o->end();
      } // Fl_Group* o
      { Fl_Group* o = new Fl_Group(660, 31, 194, 40);
        { follow_transport = new Fl_Button(662, 33, 76, 15, "Playhead");
          follow_transport->tooltip("Toggle to follow transport playhead - Shortcut \'F6\'");
          follow_transport->type(1);
          follow_transport->shortcut(0xffc3);
          follow_transport->selection_color((Fl_Color)137);
          follow_transport->labelsize(12);
          follow_transport->callback((Fl_Callback*)cb_follow_transport);
          follow_transport->align(Fl_Align(FL_ALIGN_WRAP));
        } // Fl_Button* follow_transport
        { snap_toggle_bypass = new Fl_Button(662, 53, 76, 15, "Snap");
          snap_toggle_bypass->tooltip("Toggle to bypass snapping- Shortcut \'F7\'");
          snap_toggle_bypass->type(1);
          snap_toggle_bypass->shortcut(0xffc4);
          snap_toggle_bypass->selection_color((Fl_Color)58);
          snap_toggle_bypass->labelsize(12);
          snap_toggle_bypass->callback((Fl_Callback*)cb_snap_toggle_bypass);
          snap_toggle_bypass->align(Fl_Align(FL_ALIGN_WRAP));
        } // Fl_Button* snap_toggle_bypass
        { Fl_Blink_Button* o = solo_blinker = new Fl_Blink_Button(800, 33, 50, 15, "SOLO");
          solo_blinker->box(FL_ROUNDED_BOX);
          solo_blinker->down_box(FL_ROUNDED_BOX);
          solo_blinker->color((Fl_Color)74);
          solo_blinker->selection_color((Fl_Color)92);
          solo_blinker->labeltype(FL_NORMAL_LABEL);
          solo_blinker->labelfont(1);
          solo_blinker->labelsize(11);
          solo_blinker->labelcolor(FL_GRAY0);
          solo_blinker->align(Fl_Align(FL_ALIGN_CENTER));
          solo_blinker->when(FL_WHEN_RELEASE);
          o->ignore_input( true );
        } // Fl_Blink_Button* solo_blinker
        { Fl_Blink_Button* o = rec_blinker = new Fl_Blink_Button(800, 53, 50, 15, "REC");
          rec_blinker->box(FL_ROUNDED_BOX);
          rec_blinker->down_box(FL_ROUNDED_BOX);
          rec_blinker->color(FL_DARK_RED);
          rec_blinker->selection_color(FL_RED);
          rec_blinker->labeltype(FL_NORMAL_LABEL);
          rec_blinker->labelfont(1);
          rec_blinker->labelsize(11);
          rec_blinker->labelcolor(FL_GRAY0);
          rec_blinker->align(Fl_Align(FL_ALIGN_CENTER));
          rec_blinker->when(FL_WHEN_RELEASE);
          o->ignore_input( true );
        } // Fl_Blink_Button* rec_blinker
        { Fl_Blink_Button* o = selected_blinker = new Fl_Blink_Button(745, 53, 50, 15, "SEL");
          selected_blinker->box(FL_ROUNDED_BOX);
          selected_blinker->down_box(FL_ROUNDED_BOX);
          selected_blinker->color((Fl_Color)13);
          selected_blinker->selection_color((Fl_Color)5);
          selected_blinker->labeltype(FL_NORMAL_LABEL);
          selected_blinker->labelfont(1);
          selected_blinker->labelsize(11);
          selected_blinker->labelcolor(FL_GRAY0);
          selected_blinker->align(Fl_Align(FL_ALIGN_CENTER));
          selected_blinker->when(FL_WHEN_RELEASE);
          o->ignore_input( true );
        } // Fl_Blink_Button* selected_blinker
        { Fl_Blink_Button* o = seek_blinker = new Fl_Blink_Button(745, 33, 50, 15, "SEEK");
          seek_blinker->box(FL_ROUNDED_BOX);
          seek_blinker->down_box(FL_ROUNDED_BOX);
          seek_blinker->color((Fl_Color)10);
          seek_blinker->selection_color((Fl_Color)2);
          seek_blinker->labeltype(FL_NORMAL_LABEL);
          seek_blinker->labelfont(1);
          seek_blinker->labelsize(11);
          seek_blinker->labelcolor(FL_GRAY0);
          seek_blinker->align(Fl_Align(FL_ALIGN_CENTER));
          seek_blinker->when(FL_WHEN_RELEASE);
          o->ignore_input( true );
        } // Fl_Blink_Button* seek_blinker
        o->end();
      } // Fl_Group* o
      { xrun_blinker = new Fl_Blink_Button(777, 4, 80, 15, "<XRUNS>");
        xrun_blinker->tooltip("Press button to clear xruns.");
        xrun_blinker->box(FL_UP_BOX);
        xrun_blinker->down_box(FL_DOWN_BOX);
        xrun_blinker->color(FL_BACKGROUND_COLOR);
        xrun_blinker->selection_color((Fl_Color)80);
        xrun_blinker->labeltype(FL_NORMAL_LABEL);
        xrun_blinker->labelfont(0);
        xrun_blinker->labelsize(10);
        xrun_blinker->labelcolor(FL_FOREGROUND_COLOR);
        xrun_blinker->callback((Fl_Callback*)cb_xrun_blinker);
        xrun_blinker->align(Fl_Align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE));
        xrun_blinker->when(FL_WHEN_RELEASE_ALWAYS);
      } // Fl_Blink_Button* xrun_blinker
      { stats_box = new Fl_Button(860, 0, 120, 25, "<stats>");
        stats_box->labelsize(13);
        stats_box->align(Fl_Align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE));
        stats_box->deactivate();
      } // Fl_Button* stats_box
      { sm_blinker = new Fl_Button(985, 6, 35, 15, "SM");
        sm_blinker->box(FL_ROUNDED_BOX);
        sm_blinker->down_box(FL_ROUNDED_BOX);
        sm_blinker->color(FL_DARK2);
        sm_blinker->selection_color((Fl_Color)93);
        sm_blinker->labeltype(FL_NORMAL_LABEL);
        sm_blinker->labelfont(3);
        sm_blinker->labelsize(14);
        sm_blinker->labelcolor(FL_DARK3);
        sm_blinker->align(Fl_Align(FL_ALIGN_CENTER));
        sm_blinker->when(FL_WHEN_RELEASE);
        sm_blinker->deactivate();
      } // Fl_Button* sm_blinker
      o->end();
    } // Fl_Group* o
    { progress_group = new Fl_Group(295, 352, 450, 79);
      progress_group->hide();
      { progress = new Fl_Progress(295, 394, 450, 37, "0%");
        progress->box(FL_ROUNDED_BOX);
        progress->selection_color((Fl_Color)55);
        progress->labelfont(1);
        progress->labelsize(22);
      } // Fl_Progress* progress
      { Fl_Box* o = new Fl_Box(295, 362, 450, 31, "Loading...");
        o->labelfont(1);
        o->labelsize(17);
        o->align(Fl_Align(FL_ALIGN_BOTTOM|FL_ALIGN_INSIDE));
      } // Fl_Box* o
      progress_group->end();
    } // Fl_Group* progress_group
    { Timeline* o = new Timeline(0, 75, 1025, 692, "<Timeline>");
      o->box(FL_FLAT_BOX);
      o->color(FL_DARK1);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(100);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
      Fl_Group::current()->resizable(o);
      timeline = o;
    } // Timeline* o
    { Fl_Box* o = project_name = new Fl_Box(440, 0, 305, 24, "<project name>");
      project_name->labelfont(2);
      o->label( Project::name() );
    } // Fl_Box* project_name
    o->xclass( APP_NAME );
    main_window->size_range(947, 300);
    main_window->end();
  } // TLE_Window* main_window
  return main_window;
}

int TLE::menu_picked_value( const Fl_Menu_ *m ) {
  return m->menu()[ m->value() ].flags & FL_MENU_VALUE;
}

Fl_Menu_Item * TLE::find_item( Fl_Menu_ *menu, const char *path ) {
  return const_cast<Fl_Menu_Item*>(menu->find_item( path ));
}

void TLE::update_menu() {
  Fl_Menu_Bar *m = menubar;
  
  if ( ! Project::open() )
  {
  	find_item( m, "&Project/&Compact" )->deactivate();
  	find_item( m, "&Project/&Info" )->deactivate();
  	
   	find_item( m, "&Project/Se&ttings" )->deactivate();
   	find_item( m, "&Timeline" )->deactivate();
  
  	timeline->deactivate();
  	transport->deactivate();
  }
  else
  {
  	find_item( m, "&Project/&Compact" )->activate();
  	find_item( m, "&Project/&Info" )->activate();
  
   	find_item( m, "&Project/Se&ttings" )->activate();
   	find_item( m, "&Timeline" )->activate();
  	
  	timeline->activate();
  	transport->activate();	
  }
  
  m->redraw();
  project_name->redraw();
}

void TLE::update_progress( Fl_Progress *p, char *s, float v ) {
  if ( p->value() != v )
  {
  p->value( v );
  
  snprintf( s, 5, "%d%%", (int)v );
  
  p->label( s );
  
  }
}

void TLE::update_status() {
  static char cbp[5], pbp[5], clp[5], dup[5];
  
  update_progress( capture_buffer_progress, cbp, timeline->total_input_buffer_percent() );
  update_progress( playback_buffer_progress, pbp, timeline->total_output_buffer_percent() );
  update_progress( cpu_load_progress, clp, engine ? engine->cpu_load() : 0 );
  
  {  // Color gradients for CPU
    float l = cpu_load_progress->value();
    l = l * .01;
    if ( l > 1.0) { l = 1.0; } /* prevents strange colors at high dsp load */
    /*
    for gradients see http://www.winti.de/php/farben/
    r: 0 .. 240
    g: 192 .. 0
    b: 0
    */
   int r = (int)   0 + (240 -   0) * l;
   int g = (int) 192 + (0   - 192) * l;
   int b = 0;
   cpu_load_progress->selection_color( fl_rgb_color( r,g,b ) );
  }
  
  if ( Project::open() )
     update_progress( disk_usage_progress, dup, percent_used( Project::path() ) );
  else
     update_progress( disk_usage_progress, dup, 0 );
  
  if ( timeline->total_capture_xruns() )
  	capture_buffer_progress->selection_color( FL_RED );
  
  if ( timeline->total_playback_xruns() )
  	playback_buffer_progress->selection_color( FL_RED );
  
  static char stats[100];
  static char xruns[50];
  static int d_xruns = 0;
  
  if ( engine && ! engine->zombified() )
  {
      snprintf( stats, sizeof( stats ), "Latency: %.1fms",
          engine->frames_to_milliseconds( engine->system_latency() ) );
  
      d_xruns = engine->xruns();
      snprintf( xruns, sizeof( xruns ), "XRUNS: %d",
          d_xruns );}
  else
  {
          snprintf( stats, sizeof( stats ), "%s", "DISCONNECTED" );
          snprintf( xruns, sizeof( xruns ), "%s", "XRUNS: 0" );
  }
  
  stats_box->label( stats );
  xrun_blinker->label(xruns);
  
  if(d_xruns)
      xrun_blinker->value(1);
  else
      xrun_blinker->value(0);
  
  static bool zombie = false;
  
  if ( engine && engine->zombified() && ! zombie )
  {
  	zombie = true;
  	fl_alert( "Disconnected from JACK!" );
  }
  
  solo_blinker->value( Track::soloing() );
  
  if ( transport->punch_enabled() && timeline->range_start() != timeline->range_end() )
          rec_blinker->value( transport->rolling &&
                              transport->rec_enabled() &&
                              transport->frame >= timeline->range_start() &&
                              transport->frame <= timeline->range_end() );
  else
          rec_blinker->value( transport->rolling && transport->rec_enabled() );
  
  sm_blinker->value( timeline->session_manager_name() != NULL );
  sm_blinker->tooltip( timeline->session_manager_name() );
  selected_blinker->value( timeline->nselected() );
  seek_blinker->value( timeline->seek_pending() );
  
  if ( timeline->session_manager_name() != NULL )
  {
  	find_item( menubar, "&Project/&New" )->deactivate();
  	find_item( menubar, "&Project/&Open" )->deactivate();
  }
  
  // project_name->redraw();
}

void TLE::update_cb( void *v ) {
  Fl::repeat_timeout( STATUS_UPDATE_FREQ, update_cb, v );
  
  ((TLE*)v)->update_status();
}

void TLE::capture_format_cb( Fl_Widget *, void *v ) {
  ((TLE*)v)->capture_format_cb();
}

void TLE::capture_format_cb() {
  Fl_Menu_ *o = menubar;
  
  Track::capture_format = o->menu()[ o->value() ].label();
}

void TLE::progress_cb( int p, void *arg ) {
  ((TLE*)arg)->progress_cb( p );
}

void TLE::progress_cb( int p ) {
  if ( ! progress_group->visible() )
  {
  	timeline->hide();
  	progress_group->show();
  }
  else if ( 0 == p )
  {
  	timeline->show();
  	progress_group->hide();
  }
  
  // never allow drawing timeline while loading, as this would cause lock recursion.
  if ( timeline->visible() )
     return;
  
  static int oldp;
  static char pat[10];
  
  if ( p != oldp )
  {
          oldp = p;
          nsm_send_progress( nsm, p / 100.0f );
          update_progress( progress, pat, p );
  
          progress->redraw();
  
          Fl::check();
  }
}

void TLE::show_help_dialog( const char *file ) {
  char pat[256];
  
  snprintf( pat, 256, "file://%s/non-timeline-xt/%s.html", DOCUMENT_PATH, file );
  
  open_url( pat );
}

void set_theme_dark() {
  Fl::background2( 100, 100, 100 );
          Fl::background( 50, 50, 50 );
          Fl::foreground( 255, 255, 255 );
}

void Project_Info_Dialog::cb_window_i(Fl_Double_Window* o, void*) {
  o->hide();

if ( logo_box->image() )
{
	((Fl_Shared_Image*)logo_box->image())->release();
	logo_box->image( NULL );
};
}
void Project_Info_Dialog::cb_window(Fl_Double_Window* o, void* v) {
  ((Project_Info_Dialog*)(o->user_data()))->cb_window_i(o,v);
}

void Project_Info_Dialog::cb_Save_i(Fl_Button*, void*) {
  notes_field->buffer()->savefile( "notes" );

window->do_callback();
}
void Project_Info_Dialog::cb_Save(Fl_Button* o, void* v) {
  ((Project_Info_Dialog*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void Project_Info_Dialog::cb_Discard_i(Fl_Button*, void*) {
  window->do_callback();
}
void Project_Info_Dialog::cb_Discard(Fl_Button* o, void* v) {
  ((Project_Info_Dialog*)(o->parent()->user_data()))->cb_Discard_i(o,v);
}

Project_Info_Dialog::Project_Info_Dialog() {
  make_window();
}

void Project_Info_Dialog::run() {
  window->show();
  
  while ( window->shown() )
  	Fl::wait();
}

Fl_Double_Window* Project_Info_Dialog::make_window() {
  { window = new Fl_Double_Window(520, 710, "Project info");
    window->callback((Fl_Callback*)cb_window, (void*)(this));
    { Fl_Group* o = new Fl_Group(25, 30, 470, 75);
      { Fl_Value_Output* o = new Fl_Value_Output(35, 30, 90, 25, "Sample Rate");
        o->align(Fl_Align(FL_ALIGN_TOP));
        o->value( timeline->sample_rate() );
      } // Fl_Value_Output* o
      { Fl_Output* o = new Fl_Output(175, 30, 100, 25, "Size of Journal");
        o->box(FL_UP_BOX);
        o->align(Fl_Align(FL_ALIGN_TOP));
        static char pat[40];
        snprintf( pat, sizeof( pat ), "%.1fK", size( "history" ) / (float)1024 );
        o->value( pat );
      } // Fl_Output* o
      { Fl_Output* o = new Fl_Output(315, 30, 180, 25, "Created On");
        o->box(FL_UP_BOX);
        o->textfont(11);
        o->textsize(12);
        o->align(Fl_Align(FL_ALIGN_TOP));
        o->value( Project::created_on() );
      } // Fl_Output* o
      { Fl_Output* o = new Fl_Output(25, 80, 115, 25, "Length");
        o->box(FL_BORDER_BOX);
        o->color(FL_DARK1);
        o->textcolor((Fl_Color)71);
        o->align(Fl_Align(FL_ALIGN_TOP));
        char pat[40];
        Clock::frame_to_HMS( pat, sizeof( pat ), timeline->length() );
        o->value( pat );
      } // Fl_Output* o
      { Fl_Value_Output* o = new Fl_Value_Output(195, 80, 55, 25, "Tracks");
        o->align(Fl_Align(FL_ALIGN_TOP));
        o->value( timeline->ntracks() );
      } // Fl_Value_Output* o
      { Fl_Output* o = new Fl_Output(315, 80, 180, 25, "Last Modified On");
        o->box(FL_UP_BOX);
        o->textfont(11);
        o->textsize(12);
        o->align(Fl_Align(FL_ALIGN_TOP));
        time_t t = modification_time( "history" );
        static char s[40];
        ctime_r( &t, s ); s[ strlen( s ) - 1 ] = 0;
        o->value( s );
      } // Fl_Output* o
      o->end();
    } // Fl_Group* o
    { Fl_Box* o = logo_box = new Fl_Box(18, 117, 485, 268, "<LOGO>");
      logo_box->color((Fl_Color)53);
      logo_box->labelfont(1);
      logo_box->labelsize(18);
      logo_box->align(Fl_Align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE));
      o->image( Fl_Shared_Image::get( PIXMAP_PATH "/non-timeline-xt/icon-256x256.png" ) );
      o->label( NULL );
    } // Fl_Box* logo_box
    { Fl_Text_Editor* o = notes_field = new Fl_Text_Editor(20, 420, 480, 245, "Notes:");
      notes_field->color(FL_DARK1);
      notes_field->selection_color((Fl_Color)31);
      notes_field->textsize(18);
      notes_field->textcolor((Fl_Color)92);
      o->buffer( new Fl_Text_Buffer() );
      o->buffer()->loadfile( "notes" );
    } // Fl_Text_Editor* notes_field
    { Fl_Button* o = new Fl_Button(422, 676, 74, 25, "&Save");
      o->callback((Fl_Callback*)cb_Save);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(332, 676, 74, 25, "&Discard");
      o->callback((Fl_Callback*)cb_Discard);
    } // Fl_Button* o
    window->set_modal();
    window->end();
  } // Fl_Double_Window* window
  return window;
}
